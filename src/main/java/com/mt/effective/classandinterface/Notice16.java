package com.mt.effective.classandinterface;

/**
 * @author mt 2018-11-22
 * 第16条 复合优于继承
 * 继承(inheritance)是实现代码重用的有力手段.但它并非永远是完成这项工作的
 * 最佳工具.使用不当会导致软件变的脆弱.在同一个包下,使用继承是安全的.因为
 * 子类和超类的实现基本上都在用一个程序员的控制之下.对于专门为继承而设计,并
 * 且具有良好的文档说明的类,继承也是安全的.但是对于普通的具体类进行跨包的继承
 * 则是非常危险的.例如:继承HashSet
 * 比如说,class A 继承了HashSet,A中的某个方法的实现依赖于HashSet中某个方法的
 * 实现细节,当前看来是没有问题的,但是如果在下个发行版本中,A所依赖的HashSet的实现
 * 细节发生了改变.那么class A就可能无法正常使用(A太脆弱了)
 * 复合(composition),在新类中添加一个私有域,它引用现有类的一个实例,让现有类变为
 * 新类的一个组件.复合是健壮,灵活的.
 * 继承OR复合
 * 只有当子类真正是超类的子类型(subtype)时,才适合用继承.对于两个类A,B只有当A,B
 * 确实存在"is-a"关系的时候才适合用继承
 * java标准类库中就有设计违反这一规定的例子.例如Propertise 继承了 Hashtable
 * Properties属性列表并不是Hashtable散列表.Properties想使用Hashtable的功能,
 * 应该使用复合而不是继承
 * 继承非常强大,但是也存在很多问题.它违背的封装原则.只有当子类和超类之间确实存在
 * "is-a"关系的时候才合适用继承.即便如此,如果子类和超类不在同一个包中,且超类不是
 * 为了继承而专门设计的,那么跨包继承将会导致脆弱性.避免这种脆弱性的方法就是使用复合
 *
 */
public class Notice16 {


}
